; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %riscv64_cheri_purecap_llc -verify-machineinstrs < %s | FileCheck %s

define i8 addrspace(200)* @get_ith_cap(i32 signext %i, ...) nounwind {
; CHECK-LABEL: get_ith_cap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset csp, csp, -144
; CHECK-NEXT:    csc ca7, 128(csp)
; CHECK-NEXT:    csc ca6, 112(csp)
; CHECK-NEXT:    csc ca5, 96(csp)
; CHECK-NEXT:    csc ca4, 80(csp)
; CHECK-NEXT:    csc ca3, 64(csp)
; CHECK-NEXT:    csc ca2, 48(csp)
; CHECK-NEXT:    csc ca1, 32(csp)
; CHECK-NEXT:    cincoffset ca1, csp, 32
; CHECK-NEXT:    csc ca1, 0(csp)
; CHECK-NEXT:  .LBB0_1: # %while.cond
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cgetaddr a2, ca1
; CHECK-NEXT:    addi a3, a2, 15
; CHECK-NEXT:    andi a3, a3, -16
; CHECK-NEXT:    sub a2, a3, a2
; CHECK-NEXT:    cincoffset ca2, ca1, a2
; CHECK-NEXT:    addi a3, a0, -1
; CHECK-NEXT:    cincoffset ca1, ca2, 16
; CHECK-NEXT:    sext.w a4, a0
; CHECK-NEXT:    mv a0, a3
; CHECK-NEXT:    bgtz a4, .LBB0_1
; CHECK-NEXT:  # %bb.2: # %while.end
; CHECK-NEXT:    csc ca1, 0(csp)
; CHECK-NEXT:    clc ca0, 0(ca2)
; CHECK-NEXT:    cincoffset csp, csp, 144
; CHECK-NEXT:    cret
entry:
  %ap = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %ap to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %ap.promoted = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %ap, align 16
  br label %while.cond

while.cond:
  %argp.next6 = phi i8 addrspace(200)* [ %ap.promoted, %entry ], [ %argp.next, %while.cond ]
  %i.addr.0 = phi i32 [ %i, %entry ], [ %dec, %while.cond ]
  %dec = add nsw i32 %i.addr.0, -1
  %cmp = icmp sgt i32 %i.addr.0, 0
  %1 = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* %argp.next6)
  %2 = add i64 %1, 15
  %3 = and i64 %2, -16
  %4 = call i8 addrspace(200)* @llvm.cheri.cap.address.set(i8 addrspace(200)* %argp.next6, i64 %3)
  %argp.next = getelementptr inbounds i8, i8 addrspace(200)* %4, i64 16
  br i1 %cmp, label %while.cond, label %while.end

while.end:
  store i8 addrspace(200)* %argp.next, i8 addrspace(200)* addrspace(200)* %ap, align 16
  %5 = bitcast i8 addrspace(200)* %4 to i8 addrspace(200)* addrspace(200)*
  %6 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %5, align 16
  call void @llvm.va_end.p200i8(i8 addrspace(200)* nonnull %0)
  call void @llvm.lifetime.end.p200i8(i64 8, i8 addrspace(200)* nonnull %0)
  ret i8 addrspace(200)* %6
}

declare void @varargs(i32, ...) addrspace(200) nounwind

; Make sure this goes in c1/cra rather than c2; normally 2*XLen sized and
; aligned structs go in an even integer register pair and would thus skip the
; odd register.
define void @test_varargs_odd_cap_reg() nounwind {
; CHECK-LABEL: test_varargs_odd_cap_reg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset csp, csp, -16
; CHECK-NEXT:    csc cra, 0(csp)
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    auipcc ca2, %captab_pcrel_hi(varargs)
; CHECK-NEXT:    clc ca2, %pcrel_lo(.LBB1_1)(ca2)
; CHECK-NEXT:    addi a0, zero, 1
; CHECK-NEXT:    cmove ca1, cnull
; CHECK-NEXT:    cjalr cra, ca2
; CHECK-NEXT:    clc cra, 0(csp)
; CHECK-NEXT:    cincoffset csp, csp, 16
; CHECK-NEXT:    cret
entry:
  tail call addrspace(200) void (i32, ...) @varargs(i32 1, i8 addrspace(200)* null)
  ret void
}

declare void @llvm.lifetime.start.p200i8(i64, i8 addrspace(200)* nocapture)
declare void @llvm.va_start.p200i8(i8 addrspace(200)*)
declare i64 @llvm.cheri.cap.address.get(i8 addrspace(200)*)
declare i8 addrspace(200)* @llvm.cheri.cap.address.set(i8 addrspace(200)*, i64)
declare void @llvm.va_end.p200i8(i8 addrspace(200)*)
declare void @llvm.lifetime.end.p200i8(i64, i8 addrspace(200)* nocapture)
